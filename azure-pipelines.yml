# .NET Core Function App to Windows on Azure
# Build a .NET Core function app and deploy it to Azure as a Windows function App.
# Add steps that analyze code, save build artifacts, deploy, and more:
# https://docs.microsoft.com/en-us/azure/devops/pipelines/languages/dotnet-core

trigger:
- dev

variables:
  - group: Register-API-Dev-Variables

  # Agent VM image name
  - name: vmImageName
    value: 'windows-2019'

  # Working Directory
  - name: workingDirectory
    value: 'directory'


stages:
# Static Analysis stage: This stage runs static code analysis using SonarQube and audits dependencies for vulnerabilities.
- stage: StaticAnalysis
  displayName: "Run Static Analysis"
  condition: always()
  jobs:

    # Audit job: This job audits dependencies for vulnerabilities.
    - job: Audit
      displayName: 'Audit Dependencies'
      pool:
        vmImage: ubuntu-latest
      steps:
        - task: DotNetCoreCLI@2
          inputs:
            command: 'restore'
            projects: '**/*.csproj'
          displayName: 'Restore Nuget Packages'

        - task: Bash@3
          displayName: Check NuGet vulnerabilities
          inputs:
            targetType: 'inline'
            script: |
              dotnet list package --vulnerable --include-transitive 2>&1 | tee build.log
              echo "Analyse dotnet list package command log output..."
              if grep -q -i "critical\|high" build.log; then
                  echo "Must fix security vulnerabilities found on the log output"
                  exit 1
              else
                  echo "No critical or high severity vulnerabilities found."
                  exit 0
 
# This stage runs the test suite using NUnit.
# using the DotNetCoreCLI task.
- stage: RunTests
  displayName: "Run Tests"
  jobs:
    # Test job: This job runs the test suite using NUnit.
    - job: UnitTests
      condition: always()
      displayName: Run Tests
      pool:
        vmImage: $(vmImageName)
      steps:
        # Install .NET Core SDK
        - task: UseDotNet@2
          inputs:
            version: '8.x'
        # Run NUnit tests
        - task: DotNetCoreCLI@2
          displayName: 'NUnit Tests'
          inputs:
            command: test

# Build stage: This stage compiles the .NET project, archives the build output, and publishes the artifact.
- stage: BuildAndPackage
  dependsOn: RunTests
  displayName: "Build and package"
  jobs:
    - job: Build
      displayName: Build
      pool:
        vmImage: $(vmImageName)
      steps:
        # Install .NET Core SDK
        - task: UseDotNet@2
          inputs:
            version: '8.x'

        # Restore NuGet packages using a specific Azure Artifacts feed.
        - task: DotNetCoreCLI@2
          displayName: 'Restore task'
          inputs:
            command: 'restore'
            projects: '**/*.csproj'
            feedsToUse: 'select'
            vstsFeed: 'b8db0229-c220-4583-b1d9-1111e482a1ce'

        # Build the project and output to the publish directory
        - task: DotNetCoreCLI@2
          displayName: Build
          inputs:
            command: 'build'
            projects: '**/*.csproj'
            arguments: --output $(System.DefaultWorkingDirectory)/publish_output --configuration Release

        # Archive the build output and publish the artifact
        - task: ArchiveFiles@2
          displayName: 'Archive files'
          inputs:
            rootFolderOrFile: '$(System.DefaultWorkingDirectory)/publish_output'
            includeRootFolder: false
            archiveType: zip
            archiveFile: $(Build.ArtifactStagingDirectory)/$(Build.BuildId).zip
            replaceExistingArchive: true
        - publish: $(Build.ArtifactStagingDirectory)/$(Build.BuildId).zip
          artifact: drop

# Deploy stage: This stage deploys the build artifact to the Azure Function App.
- stage: Deploy
  displayName: Deploy stage
  dependsOn: Build
  condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/dev'))

  jobs:
    # Deploy job: This job deploys the build artifact to the Azure Function App.
    - deployment: Deploy
      displayName: Deploy
      environment: 'development'
      pool:
        vmImage: $(vmImageName)

      strategy:
        runOnce:
          deploy:
            steps:
              # Deploy to Azure Function App
              - task: AzureFunctionApp@2
                inputs:
                  connectedServiceNameARM: $(ConnectedServiceName)
                  appType: 'functionApp'
                  appName: $(FunctionAppName)
                  package: '$(Pipeline.Workspace)/drop/$(Build.BuildId).zip'
                  deploymentMethod: 'auto'



























